---
title: 12. Binary Search Trees
# description: Short summary of the post
date: 2024-12-12 21:27
categories: [Computer Science, Algorithm]
tags: [binary-search-tree]     # TAG names should always be lowercase
math: true
pin: false
---

The search tree data structure supports many dynamic-set operations, including SEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, and DELETE.
We can use a search tree both as a dictionary and as a priority queue.  
Basic operations on a binary search tree take time proportional to the height of the tree.
For a complete binary tree with $$ n $$ nodes, such operations run in $$ \Theta(\lg n) $$ worst-case time.
If the tree is a linear chain of $$ n $$ nodes, however, the same operations run in $$ \Theta(\lg n) $$ worst-case time.
Since the expected height of a randomly built binary search tree is $$ O(\lg n) $$, so that basic dynamic-set operations on such a tree take $$ \Theta(\lg n) $$ time on average.

## 12.1 What is a binary search tree?

A binary search tree is organized, as the name suggests, in a binary tree.
We can represent such a tree by a linked data structure in which each node is an object.
In addition to a key and satellite data, each node contains attributes $$ left $$, $$ right $$, and $$ p $$ that point to the nodes corresponding to its left child, its right child, and its parent, respectively.  
The keys in a binary search tree are always stored in such a way as to satisfy the binary-search-tree property:

>Let $$ x $$ be a node in a binary search tree.
>If $$ y $$ is a node in the left subtree of $$ x $$, then $$ y.key \le x.key $$.
>If $$ y $$ is a node in the right subtree of $$ x $$, then $$ y.key \ge x.key $$.

The binary-search-tree property allows us to print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an inorder tree walk.
This algorithm prints the key of the root of a subtree between printing the values in its left subtree and printing those in its right subtree.
Similarly, a preorder tree walk prints the root before the values in either subtree, and a postorder tree walk prints the root after the values in its subtrees.

>INORDER-TREE-WALK($$ x $$) \\
>01&nbsp; if $$ x \neq $$ NIL  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;INORDER-TREE-WALK($$ x.left $$)  
>03&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;print $$ x.key $$  
>04&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;INORDER-TREE-WALK($$ x.right $$)  

The correctness of the algorithm follows by induction directly from the binary-search-tree property.
It takes $$ \Theta(n) $$ time to walk an $$ n $$-node binary search tree, since after the initial call, the procedure calls itself recursively exactly twice for each node in the treeâ€”once for its left child and once for its right child.

### Theorem 12.1

If $$ x $$ is the root of an $$ n $$-node subtree, then the call INORDER-TREE-WALK($$ x $$) takes $$ \Theta(n) $$ time.

**Proof**  
Let $$ T(n) $$ denote the time taken by INORDER-TREE-WALK when it is called on the root of an $$ n $$-node subtree.
