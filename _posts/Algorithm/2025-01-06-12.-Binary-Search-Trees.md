---
title: 12. Binary Search Trees
# description: Short summary of the post
date: 2024-12-12 21:27
categories: [Computer Science, Algorithm]
tags: [binary-search-tree]     # TAG names should always be lowercase
math: true
pin: false
---

The search tree data structure supports many dynamic-set operations, including SEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, and DELETE.
We can use a search tree both as a dictionary and as a priority queue.  
Basic operations on a binary search tree take time proportional to the height of the tree.
For a complete binary tree with $$ n $$ nodes, such operations run in $$ \Theta(\lg n) $$ worst-case time.
If the tree is a linear chain of $$ n $$ nodes, however, the same operations run in $$ \Theta(\lg n) $$ worst-case time.
Since the expected height of a randomly built binary search tree is $$ O(\lg n) $$, so that basic dynamic-set operations on such a tree take $$ \Theta(\lg n) $$ time on average.

## 12.1 What is a binary search tree?

![Desktop View](/assets/img/12-Binary-Search-Trees/Figure 12.1.png){: width="700"}

A binary search tree is organized, as the name suggests, in a binary tree.
We can represent such a tree by a linked data structure in which each node is an object.
In addition to a key and satellite data, each node contains attributes $$ left $$, $$ right $$, and $$ p $$ that point to the nodes corresponding to its left child, its right child, and its parent, respectively.  
The keys in a binary search tree are always stored in such a way as to satisfy the binary-search-tree property:

>Let $$ x $$ be a node in a binary search tree.
>If $$ y $$ is a node in the left subtree of $$ x $$, then $$ y.key \le x.key $$.
>If $$ y $$ is a node in the right subtree of $$ x $$, then $$ y.key \ge x.key $$.

The binary-search-tree property allows us to print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an inorder tree walk.
This algorithm prints the key of the root of a subtree between printing the values in its left subtree and printing those in its right subtree.
Similarly, a preorder tree walk prints the root before the values in either subtree, and a postorder tree walk prints the root after the values in its subtrees.

>INORDER-TREE-WALK($$ x $$)  
>01&nbsp; if $$ x \neq $$ NIL  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;INORDER-TREE-WALK($$ x.left $$)  
>03&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;print $$ x.key $$  
>04&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;INORDER-TREE-WALK($$ x.right $$)  

The correctness of the algorithm follows by induction directly from the binary-search-tree property.
It takes $$ \Theta(n) $$ time to walk an $$ n $$-node binary search tree, since after the initial call, the procedure calls itself recursively exactly twice for each node in the tree—once for its left child and once for its right child.

### Theorem 12.1

If $$ x $$ is the root of an $$ n $$-node subtree, then the call INORDER-TREE-WALK($$ x $$) takes $$ \Theta(n) $$ time.

**Proof**  
Let $$ T(n) $$ denote the time taken by INORDER-TREE-WALK when it is called on the root of an $$ n $$-node subtree.
Since INORDER-TREE-WALK visits all $$ n $$ nodes of the subtree, we have $$ T(n) = \Omega(n) $$.  
Since INORDER-TREE-WALK takes a small, constant amount of time on an empty subtree (for the test $$ x \neq $$ NIL), we have $$ T(0) = c $$ for some constant $$ c > 0 $$.
For $$ n > 0 $$, suppose that INORDER-TREE-WALK is called on a node $$ x $$ whose left subtree has $$ k $$ nodes and whose right subtree has $$ n - k - 1 $$ nodes.
The time to perform INORDER-TREE-WALK($$ x $$) is bounded by $$ T(n) \le T(k) + T(n - k - 1) + d $$ for some constant $$ d > 0 $$ that reflects an upper bound on the time to execute the body of INORDER-TREE-WALK($$ x $$).
We use the substitution method to show that $$ T(n) = O(n) $$ by proving that $$ T(n) \le (c + d) n + c $$.
For $$ n = 0 $$, we have $$ (c + d) \cdot 0 + c = c = T(0) $$.
For $$ n > 0 $$, we have

$$
\begin{align*}
    T(n) &\le T(k) + T(n - k - 1) + d \\
         &= ((c + d) k + c) + ((c + d) (n - k - 1) + c) + d \\
         &= (c + d) n + c - (c + d) + c + d \\
         &= (c + d) n + c
\end{align*}
$$

which completes the proof. $$ \blacksquare $$

## 12.2 Querying a binary search tree

### Searching

>TREE-SEARCH($$ x, \ k $$)  
>01&nbsp; if $$ x == $$ NIL or $$ k == x.key $$  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;return $$ x $$  
>03&nbsp; if $$ k < x.key $$  
>04&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;return TREE-SEARCH($$ x.left, \ k $$)  
>05&nbsp; else return TREE-SEARCH($$ x.right, \ k $$)

The procedure begins its search at the root and traces a simple path downward in the tree.
For each node $$ x $$ it encounters, it compares the key $$ k $$ with $$ x.key $$.
If the two keys are equal, the search terminates.
If $$ k $$ is smaller than $$ x.key $$, the search continues in the left subtree of $$ x $$, since the binary-search-tree property implies that $$ k $$ could not be stored in the right subtree.
Symmetrically, if $$ k $$ is larger than $$ x.key $$, the search continues in the right subtree.
The nodes encountered during the recursion form a simple path downward from the root of the tree, and thus the running time of TREE-SEARCH is $$ O(h) $$, where $$ h $$ is the height of the tree.  
We can rewrite this procedure in an iterative fashion by unrolling the recursion into a while loop.

>ITERATIVE-TREE-SEARCH($$ x, \ k $$)  
>01&nbsp; while $$ x \neq $$ NIL and $$ k \neq x.key $$  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;if $$ k < x.key $$  
>03&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ x = x.left $$  
>04&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;else $$ x = x.right $$  
>05&nbsp; return $$ x $$

### Minimum and maximum

We can always find an element in a binary search tree whose key is a minimum by following $$ left $$ child pointers from the root until we encounter a NIL.

>TREE-MINIMUM($$ x $$)  
>01&nbsp; while $$ x.left \neq $$ NIL  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ x = x.left $$  
>03&nbsp; return $$ x $$  

The binary-search-tree property guarantees that TREE-MINIMUM is correct.  
The pseudocode for TREE-MAXIMUM is symmetric:

>TREE-MAXIMUM($$ x $$)  
>01&nbsp; while $$ x.right \neq $$ NIL  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ x = x.right $$  
>03&nbsp; return $$ x $$  

Both of these procedures run in $$ O(h) $$ time on a tree of height $$ h $$ since, as in TREE-SEARCH, the sequence of nodes encountered forms a simple path downward from the root.

### Successor and predecessor

If all keys are distinct, the successor of a node $$ x $$ is the node with the smallest key greater than $$ x.key $$.
The structure of a binary search tree allows us to determine the successor of a node without ever comparing keys.

>TREE-SUCCESSOR($$ x $$)  
>01&nbsp; if $$ x.right \neq $$ NIL  
>02&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;return TREE-MINIMUM($$ x.right $$)  
>03&nbsp; $$ y = x.p $$  
>04&nbsp; while $$ y \neq $$ NIL and $$ x == y.right $$  
>05&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ x = y $$  
>06&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ y = y.p $$  
>07&nbsp; return $$ y $$

Sometimes we need to find its successor in the sorted order determined by an inorder tree walk.
If the right subtree of node $$ x $$ is nonempty, then the successor of $$ x $$ is the leftmost node in $$ x $$'s right subtree, which we find in line 2 by calling TREE-MINIMUM($$ x.right $$).
On the other hand, if the right subtree of node $$ x $$ is empty and $$ x $$ has a successor $$ y $$, then $$ y $$ is the lowest ancestor of $$ x $$ whose left child is also an ancestor of $$ x $$.
Lines 3–7 handle this case.  
The running time of 